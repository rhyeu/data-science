---
layout: page
title: 데이터 과학
subtitle: R 언어
output:
  html_document: 
    theme: journal
    toc: yes
    highlight: tango
    code_folding: show
mainfont: NanumGothic
---


``` {r, include=FALSE}
source("tools/chunk-options.R")
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)

# 0. 환경설정 --------------
library(timelineS) # devtools::install_github("daheelee/timelineS")
library(tidyverse)
library(lubridate)
library(googleVis)

rhistory_df <- tribble(
    ~event, ~event_date, ~event_eng,
    "R 개발시작", "1992-07-01", "R development begins as a research project in Auckland, NZ by Robert Gentleman and Ross Ihaka",
    "R 배포", "1993-07-01", "First binary versions of R published at Statlib",
    "GPL 소스코드 \n 배포", "1995-07-01", "R first distributed as open-source software, under GPL2 license",
    "R 그룹 생성", "1997-07-01", "R core group formed",
    "CRAN 시작", "1997-07-01", "CRAN founded (by Kurt Jornik and Fritz Leisch)",
    "R 웹사이트", "1999-07-01", "The R website, r-project.org, founded",
    "R 개발자 \n 모임", "1999-07-01", "First in-person meeting of R Core team, at inaugural Directions in Statistical Computing conference, Vienna",
    "R 1.0.0 배포", "2000-02-29", "R 1.0.0 released (February 29)",
    "John Chambers \n ACM 수상", "2000-07-01", "John Chambers, recipient of the 1998 ACM Software Systems Award for the S language, joins R Core",
    "R 소식지 창단", "2001-07-01", "R News founded (later to become the R Journal)",
    "R 재단 창설", "2003-07-01", "R Foundation founded",
    "UseR! 컨퍼런스 시작", "2004-07-01", "First UseR! conference (in Vienna)",
    "R 2.0.0 배포", "2004-07-01", "R 2.0.0 released",
    "첫 R 저널 배포", "2009-07-01", "First edition of the R Journal",
    "R 3.0.0 배포", "2013-07-01", "R 3.0.0 released",
    "R 컨소시엄 창설", "2015-07-01", "R Consortium founded, with R Foundation participation",
    "신규 R 로고 채택", "2016-07-01", "New R logo adopted",
    "한국 R Meetup", "2017-08-23", "한국 R Meetup 시작"
)

```

> ## 학습 목표 {.objectives}
>
> * R 언어의 역사를 이해한다.
> * 통계 팩키지와 다른 데이터과학 언어를 R 언어과 비교한다.
> * 사용자와 개발자를 나누는 사회적 장벽을 이해하고, 두언어 문제를 살펴본다.
> * 주요 R언어 구문을 이해한다.
> * R 언어 시작과 끝을 맛본다.

## 1. R 역사 [^r-history] {#rhistory}

[^r-history]: [Revolutions (2017), An Updated History of R](http://blog.revolutionanalytics.com/2017/10/updated-history-of-r.html)

[Revolutions](http://blog.revolutionanalytics.com/2017/10/updated-history-of-r.html)에서 정리한 최근 R 역사는 
1992년 처음 뉴질랜드 오클랜드에서 Robert Gentleman, Ross Ihaka 교수가 개발을 시작한 후에 
GPL 라이선스를 장착하여 소스코드를 공개한 후에 R 코어 그룹이 만들어지고, 팩키지 배포 CRAN이 순차적으로 공개되고 나서,
[R 웹사이트](https://www.r-project.org/)가 만들어지고, 처음으로 2000년에 R 1.0.0 으로 배포되고 R 저널, UseR! 컨퍼런스, 
R 재단, R 컨소시엄이 전세계 수많은 재능있고 열정있는 수많은 사람에 의해서 만들어졌습니다. 
그리고 한국에서도 [R Meetup](https://github.com/KaggleBreak/xwmooc_Rmeetup)을 2017년부터 시작되었습니다.

``` {r rhistory, fig.width=12}
# 1. R 역사 연대기 표 --------------

DT::datatable(rhistory_df)

# 2. R 역사 연대기 시각화 --------------

rhistory_df <- rhistory_df %>% 
    mutate(event_date = ymd(event_date))

timelineS(rhistory_df, main = "R 연대기", buffer.days = 3600,
          label.direction = "up", label.length = c(0.2,0.8,0.4,1.2), label.position = 3,
          labels = rhistory_df[[1]])
```


## 2. 통계팩키지 SAS/SPSS/Stata 주요 구성요소 비교 [^r4sas-spss] {#comparison-with-packages}

R은 현존하는 가장 강력한 통계 컴퓨팅 언어로, 그래픽과 자료분석을 위해 언어 + 팩키지 + 환경이 하나로 묶여있다.
특히, 컴퓨터 주기억장치 한계가 존재하지만, 오픈 소스로 모든 코드가 공개되어 있어 자유로이 이용이 가능하다. R은 John Chambers가 주축이 되어 벨연구소에서 
개발된 유닉스와 역사를 함께하는 S을 Ross Ihaka 와 Robert Gentleman이 1996년 구현하여 대중에게 공개하였다. 

[^r4sas-spss]: [Muenchen, Robert A. R for SAS and SPSS users. Springer Science & Business Media, 2011.](http://www.springer.com/us/book/9780387094182)

자료분석을 위해 대중에게 널리 알려진 통계팩키지에는 SAS, SPSS, Stata, Minitab 등 상업용으로 많이 판매되고 있다. 어떤 통계팩키지도 다음과 같은 공통된 5가지 구성요소를 포함하고 있다.

* 데이터 입력과 조작 언어
* 통계와 그래픽 명령어
* 출력물 관리 시스템
* 매크로 언어
* 행렬 언어(SAS IML/SPSS Matrix/Stata Mata) 

이와 비교하여 R은 5가지 구성요소가 **언어 + 팩키지 + 환경** 으로 구성된다는 점에서 차이가 크다.

## 3. 두 언어 문제 [^Ousterhout-dichotomy] {#two-language-problem}

<iframe width="320" height="200" src="https://www.youtube.com/embed/B9moDuSYzGo" frameborder="0" allowfullscreen></iframe>

[^Ousterhout-dichotomy]: [Ousterhout dichotomy](https://en.wikipedia.org/wiki/Ousterhout%27s_dichotomy)

[ODSC East 2016 - Stefan Karpinski - "Solving the Two Language Problem"](https://www.youtube.com/watch?v=B9moDuSYzGo)

| 시스템 언어  | Ousterhout 이분법  | 스크립트 언어  |
|-------------|-------------|-------------|
|   정적       |     --      |     동적     |
|   컴파일      |     --      |    인터프리터 |
| 사용자정의 자료형|     --      |  표준 자료형 |
|   빠른 속도   |     --      |   늦은 속도   |
|   어려움       |     --      |   쉬움     |

두 언어 문제로 인해 편리함을 위해 파이썬, R, Matlab을 사용하고 C/C++, 포트란 시스템 언어로 모든 힘든 작업을 수행한다.
시스템 언어와 스크립트 언어의 두가지 문제점을 해결하기 위해서 두가지 다른 언어의 장점을 취하고 이를 보완하려는 노력이 지속적으로 경주되고 있다.

<img src="fig/data-scientist-languages.png" alt="데이터 과학자 언어" width="50%">

과거 데이터 과학자가 선형대수, 통계&시각화, 속도, 통합작업과 관련하여 다양한 언어와 도구를 익혀야 했지만,
2010년 중반을 넘어서는 현시점에서 파이썬과 R을 함께 사용하는 것으로 중지가 모아지고 있다.

## 4. 왜 R 언어인가? [^r-rank] [^r-r4stats] {#why-r}

[Rexer Analytics](http://www.rexeranalytics.com/)가 2015년 응답자 1,220명을 대상으로 실시한 결과 R이 데이터 분석 소프트웨어 분야에서 압도적인 1위 위치를 점유하고 있음을 확인할 수 있다.

[^r-rank]: [Interactive-The Top Programming Languages](http://spectrum.ieee.org/static/interactive-the-top-programming-languages#index)

[^r-r4stats]: [The Popularity of Data Analysis Software](http://r4stats.com/articles/popularity/)


| | |
|-----------------------------------|-----------------------------------|
|<img src="fig/rexersurveyalltools2015.png" alt="Rexer Analytics 설문조사 2015 (응답자 1,220)" width="70%"> | <img src="fig/ieee-r-ranking.png" alt="IEEE 조사" width="70%">

R이 1등을 하는 분야는 없지만, 2017년 10월 기준 [스택오버플로우-What are the Most Disliked Programming Languages?](https://stackoverflow.blog/2017/10/31/disliked-programming-languages/) 블로그를 
참조하면 가장 싫어하지 않는 언어 1위에 등극했습니다.

<img src="fig/languages-r-dislike.png" alt="가장 혐오하지 않는 언더" width="77%" />

## 5. R 시작과 끝 (맛보기) {#r-a-bit-taste}

R이 설치되고, 필요한 패키지가 준비되면 분석에 사용할 데이터를 작업 메모리상에 올려야 한다. 
분석 데이터를 R 작업공간에 준비하는 방법은 어려가지가 있다. 
Web URL을 활용한 웹 데이터를 가져오거나, `read.table`을 이용한 로컬 디스크 상의 데이터를 메모리로 불러올 수 있다.

``` {r r-lang-import, message=FALSE, warning=FALSE, comment=FALSE}
abalone <- read.csv(url("http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data"), header=F)
names(abalone) <- c("Sex","Length","Diameter","Height","Whole weight","Shucked weight","Viscera weight","Shell weight","Rings")
head(abalone)
#   Sex Length Diameter Height Whole weight Shucked weight  Viscera weight Shell weight Rings
# 1   M  0.455    0.365  0.095       0.5140         0.2245          0.1010        0.150    15
# 2   M  0.350    0.265  0.090       0.2255         0.0995          0.0485        0.070     7
# 3   F  0.530    0.420  0.135       0.6770         0.2565          0.1415        0.210     9
# 4   M  0.440    0.365  0.125       0.5160         0.2155          0.1140        0.155    10
# 5   I  0.330    0.255  0.080       0.2050         0.0895          0.0395        0.055     7
# 6   I  0.425    0.300  0.095       0.3515         0.1410          0.0775        0.120     8
```

분석을 진행하기 위해서 간단한 R 스크립트를 작성하여 보자. 
메뉴상단의 `File > New File > R Script` 혹은 `CTRL+SHIFT+N` 단축키를 사용하여 데이터 분석 결과를 스크립트로 작성하여 저장할 수 있다. 
분석이 완료된 스크립트는 `SimpleR.R`로 저장한다.

``` {r r-lang-table-plot}
# 기본 분석 스크립트
# abalone <- read.csv("abalone.csv")
table(abalone$Sex)
plot(Length ~ Sex, data=abalone)
```

자료 분석 결과는 코드, 데이터, 그래프, 테이블로 나타나게 되며, 
이를 하나의 문서로 각각 정리하는 것은 매우 수고스러운 일이며 기본적으로 기계나 컴퓨터가 해야되는 일중의 하나이다. 
이를 위해서 RStudio의 Notebook 기능을 사용한다. 
먼저 RStudio의 Notebook 도 `knitr` 패키지와 `Rmarkdown` 같은 패키지를 기반으로 하지만 
`knitr` 패키지를 설치하면 모든 의존성을 자동으로 해결해 준다. 
`knitr` 패키지를 설치한 후에 메뉴상단의 `File > Compile Notebook…` 을 클릭하면 
팝업메뉴가 뜨며 제목과 저자를 표시하면 코드, 데이터, 그래프, 테이블 등 정리된 결과를 HTML 파일로 얻을 수 있다. 

R 코드, 그림, 테이블, 텍스트와 함께 하나의 작업파일로 데이터 제품을 만들 수 있다. 
노트북(Notebook), 마크다운(Markdown), HTML, LaTex 등 총 4가지 방법이 있으나 
RStudio를 사용할 경우 내장된 노트북 기능을 사용하는 것도 좋은 방법이며, 
마크다운, LaTex, HTML등 친숙한 방법을 사용할 수도 있다.

| **Markup 시스템** | **입력파일(Input)** | **리포트파일(Output)** |
|-------------------|---------------------|------------------------|
| 노트북            | `.R`                | `.html` (`.md` 경유)   |
| 마크다운          | `.Rmd`              | `.html` (`.md` 경유)   |
| HTML	            | `.Rhtml`            | `.html`                |
| `LaTeX`           | `.Rnw`              | `.pdf` (.tex 경유)     |


RStudio_RMarkdown 을 이용하여 작업파일을 만든 후에 `knit HTML` 버튼을 누루면 HTML 파일을 바로 얻을 수 있다. 

어느 소프트웨어도 마찬가지지만 사용하다보면 오류가 발생하고 이를 확인해야 할 때가 있다. 
`RStudio`의 경우 `Help>Diagnostics>Show log files` 를 통해서 확인가능하다. 
`R`과 `Rstudio` 관련 도움말은 구글 검색이나, [stack exchange](http://stackexchange.com/)를 통해 얻을 수 있다. 
작업을 하다면 콘솔화면을 깨끗이하고 다시 시작하고 싶은 경우가 있다. 
윈도나 도스의 경우 `cls` 명령어가 있는데 R에는 딱히 그런 명령어가 없다. 이런 경우 사용자 정의 함수를 하나 만들어서 실행할 수 있다. 

``` {r r-lang-cls}
cls <- function() cat(rep("\n",50))
cls()
```

하지만, 매번 R을 실행할 때마다 반복적으로 해야되기 때문에 R이 시작될 때 자동으로 설정을 하는 방법은 초기 실행 환경파일에 이를 적용하는 것이다. 
`C:\Program Files\R\R-3.1.0\library\base\R\RProfile` 파일을 텍스트 편집기로 열어 하단에 `cls` 함수를 적어두고 저장한다. 
혹은, `CTRL+L` 키를 눌러 화면을 깨끗이하며 커서를 맨 위 상단으로 이동한다.

``` {r r-lang-cls-rprofile}
local({
    br <- Sys.getenv("R_BROWSER", NA_character_)
    if(!is.na(br)) options(browser = br)
    tests_startup <- Sys.getenv("R_TESTS")
    if(nzchar(tests_startup)) source(tests_startup)
})

# 사용자 정의함수
cls <- function() cat(rep("\n",50))
``` 

## 6. R 구문(Syntax) {#r-syntax}

[Amelia McNamara](http://t.co/6UotowCWjt) 교수는 "R Syntax Comparison:: cheat sheet"를 작성했다. 
이를 한국어로 번역한 컨닝쪽지는 [R 구문 비교::컨닝 쪽지](https://github.com/rstudio/cheatsheets/raw/master/translations/korean/syntax-kr.pdf)를 통해 비교가 가능하다.

**구문(Syntax)** 프로그래밍 언어에서 어떤 코드는 동작하고 어떤 코드는 동작하지 않는지 관할하는 규칙의 집합이다. 
대부분의 프로그래밍 언어는 한가지 표준화된 구문을 제공하지만, 
R 언어는 팩키지 개발자가 자체 구문을 제작하여 명세하는 것이 허락되어 있다. 결과로, 매우 다양한 (동일하게 적법한) R 구문이 존재하게 되었다.

가장 널리 퍼진 R 구문은 다음과 같다:

1. **달러 기호 구문**, 때때로 베이스 R 구문으로 불리며 대부분의 베이스 R 함수에서 활용된다. 
데이터셋$변수명형태로 특징되고, 데이터셋[1,2]와 같이 꺾쇠 괄호 부분집합 추출하는 것과 연관된다. 
거의 모든 R 함수는 달러기호 구문을 인자로 전달하는 것이 허용한다.

2. **모형공식 구문**, lm(), lattice 그래픽 같은 모형함수에서 사용됨. 하나 (혹은 다수) 예측변수를 종속변수에 연결시키는데 틸드(~)를 사용한다. 다수 베이스 R 함수는 모형공식 구분을 받아들인다.

3. **깔끔한 세상(tidyverse syntax)**, `dplyr`, `tidyr`, 등에서 사용된다. 
이런 유형의 함수는 데이터가 첫번째 인자로 상정하고, `magrittr` 팩키지 “파이프” (%>%) 연산자와 함께 동작할 수 있도록 한다. 
일반적으로 `ggplot2`는 깔끔한 세상(tidyverse) 생태계 일원으로 간주되지만, 
자체 구문으로 더하기 기호(+)를 사용해서 문자열 조각을 결합하는데 사용한다. 
Hadley Wickham은 파이프를 학습한 후에 `ggplot2`를 작성했다면 지금과는 다른 구문을 갖게되었을 것이라 말을 했다.

교육서비스를 제공하는 입장에서 통일된 하나의 구문을 가르치려고 하지만, 대부분의 R 프로그래머는 다양한 구문을 조합해서 사용하는 것이 현실이다.

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Thank you <a href="https://twitter.com/AmeliaMN?ref_src=twsrc%5Etfw">@AmeliaMN</a> for making an <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> cheatsheet that compares the $, formula and <a href="https://twitter.com/hashtag/tidyverse?src=hash&amp;ref_src=twsrc%5Etfw">#tidyverse</a> coding styles in R. Now at <a href="https://t.co/OZVUTm5lDl">https://t.co/OZVUTm5lDl</a> <a href="https://twitter.com/rstudio?ref_src=twsrc%5Etfw">@rstudio</a> <a href="https://t.co/1BJDbxak83">pic.twitter.com/1BJDbxak83</a></p>&mdash; Garrett Grolemund (@StatGarrett) <a href="https://twitter.com/StatGarrett/status/961737092937277440?ref_src=twsrc%5Etfw">February 8, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

### 6.1. 달러($) 기호 구문 {#r-syntax-dollar}

> `목표함수명(데이터$x, 데이터$y)`

#### 6.1.1. 요약 통계량 {#r-syntax-dollar-stat}

목표함수명을 가정하면 `데이터셋$변수명` 형태로 R 구문을 작성한다.

``` {r r-syntax-dollar-stat, eval = FALSE}
#연속형 변수 1개:
mean(mtcars$mpg)
#범주형 변수 1개:
table(mtcars$cyl)
#범주형 변수 2개:
table(mtcars$cyl, mtcars$am)
#연속형 1개, 범주형 1개:
mean(mtcars$mpg[mtcars$cyl==4])
mean(mtcars$mpg[mtcars$cyl==6])
mean(mtcars$mpg[mtcars$cyl==8])
```

#### 6.1.2. 플롯 그래프 {#r-syntax-dollar-plot}

통계분석에 사용되는 것과 동일한 방식 `데이터셋$변수명` 형태로 R 구문을 작성하여 시각화 플롯 그래프를 도식화한다.

``` {r r-syntax-dollar-graph, eval = FALSE}
# 연속형 변수 1개:
hist(mtcars$disp)
boxplot(mtcars$disp)
# 범주형 변수 1개:
barplot(table(mtcars$cyl))
# 연속형 변수 2개:
plot(mtcars$disp, mtcars$mpg)
# 범주형 변수 2개:
mosaicplot(table(mtcars$am, mtcars$cyl))
# 연속형 1개, 범주형 1개:
histogram(mtcars$disp[mtcars$cyl==4])
histogram(mtcars$disp[mtcars$cyl==6])
histogram(mtcars$disp[mtcars$cyl==8])
boxplot(mtcars$disp[mtcars$cyl==4])
boxplot(mtcars$disp[mtcars$cyl==6])
boxplot(mtcars$disp[mtcars$cyl==8])
```

#### 6.1.3. 데이터 정제작업 (WRANGLING) {#r-syntax-dollar-wrangling}

통계분석과 플롯 그래프 시각화와 동일한 방식 `데이터셋$변수명` 형태로 R 구문을 작성하여 데이터 정제작업을 수행한다.

``` {r r-syntax-dollar-wrangle, eval = FALSE}
# 부분집합 뽑아내기(subsetting):
mtcars[mtcars$mpg>30, ]
# 신규 변수 생성:
mtcars$efficient[mtcars$mpg>30] <- TRUE
mtcars$efficient[mtcars$mpg<30] <- FALSE
```

### 6.2. 모형공식 구문 {#r-syntax-formula}

> `목표함수명(y~x|z, data=데이터, group=w)`

#### 6.2.1. 요약 통계량 {#r-syntax-formula-stat}

목표함수명을 가정하면 모형공식으로 많이 사용되는 `~` 틸드를 사용하여 R 구문을 작성한다.

``` {r r-syntax-formula-stat, eval = FALSE}
# 연속형 변수 1개:
mosaic::mean(~mpg, data=mtcars)
# 범주형 변수 1개:
mosaic::tally(~cyl, data=mtcars)
# 범주형 변수 2개:
mosaic::tally(cyl~am, data=mtcars)
# 연속형 1개, 범주형 1개:
mosaic::mean(mpg~cyl, data=mtcars)
```

#### 6.2.2. 플롯 그래프 {#r-syntax-formula-plot}

통계분석에 사용되는 것과 동일한 방식 모형공식으로 많이 사용되는 `~` 틸드를 사용하여 R 구문을 작성하여 시각화 플롯 그래프를 도식화한다.

``` {r r-syntax-formula-plot, eval = FALSE}
# 연속형 변수 1개:
lattice::histogram(~disp, data=mtcars)
lattice::bwplot(~disp, data=mtcars)
# 범주형 변수 1개:
mosaic::bargraph(~cyl, data=mtcars)
# 연속형 변수 2개:
lattice::xyplot(mpg~disp, data=mtcars)
# 범주형 변수 2개:
mosaic::bargraph(~am, data=mtcars, group=cyl)
# 연속형 1개, 범주형 1개:
lattice::histogram(~disp|cyl, data=mtcars)
lattice::bwplot(cyl~disp, data=mtcars)
```

### 6.3. 깔끔한 세상(Tidyverse) 구문 {#r-syntax-tidyverse}

> `데이터 %>% 목표함수명(x)`

### 6.3.1. 요약 통계량 {#r-syntax-tidyverse-stat}

`%>%` 연산자를 사용하여 R 구문을 작성하여 요약통계량을 산출한다.

``` {r r-syntax-tidyverse-stat, eval = FALSE}
# 연속형 변수 1개:
mtcars %>% dplyr::summarize(mean(mpg))
# 범주형 변수 1개:
mtcars %>% dplyr::group_by(cyl) %>% dplyr::summarize(n())
# 범주형 변수 2개:
mtcars %>% dplyr::group_by(cyl, am) %>% dplyr::summarize(n())
# 연속형 1개, 범주형 1개:
mtcars %>% dplyr::group_by(cyl) %>% dplyr::summarize(mean(mpg))
```

### 6.3.2. 플롯 그래프 {#r-syntax-tidyverse-plot}

`%>%` 연산자를 역할을 수행하는 `+` 연산자를 활용하여 R 구문을 작성하여 시각화 플롯 그래프를 도식화한다.
`qplot`은 `ggplot2`의 기능을 간추려 빠르게 고급 시각화 산출물을 작성할 수 있도록 한다.

``` {r r-syntax-tidyverse-plot, eval = FALSE}
# 연속형 변수 1개:
ggplot2::qplot(x=mpg, data=mtcars, geom = "histogram")
ggplot2::qplot(y=disp, x=1, data=mtcars, geom="boxplot")
# 범주형 변수 1개:
ggplot2::qplot(x=cyl, data=mtcars, geom="bar")
# 연속형 변수 2개:
ggplot2::qplot(x=disp, y=mpg, data=mtcars, geom="point")
# 범주형 변수 2개:
ggplot2::qplot(x=factor(cyl), data=mtcars, geom="bar") + facet_grid(.~am)
#  연속형 1개, 범주형 1개:
ggplot2::qplot(x=disp, data=mtcars, geom = "histogram") + facet_grid(.~cyl)
ggplot2::qplot(y=disp, x=factor(cyl), data=mtcars,geom="boxplot")
```

### 6.3.3. 데이터 정제작업(Wrangling) {#r-syntax-tidyverse-wrangle}

`%>%` 연산자를 활용하여 R 구문을 작성하여 데이터 정제작업을 정말 깔끔하게 수행할 수 있다.

``` {r r-syntax-tidyverse-wrangle, eval = FALSE}
# 부분집합 뽑아내기(subsetting):
mtcars %>% dplyr::filter(mpg>30)
# 신규 변수 생성: 
mtcars <- mtcars %>% dplyr::mutate(efficient = if_else(mpg>30, TRUE, FALSE))
```
