---
layout: page
title: 데이터 과학
subtitle: 연산자
---

### 연산자

측정치로 되돌아가 보자. Notebook 1 파일에는 장소, 날짜, 
그리고 구분자로 탭으로 구부된 악마레벨이 기록되어 있다.
일부 장소명(site)에는 공백이 있고, 날짜(date)는
YYYY-MM-DD 국제표준형식으로 되어 있다.
하지만, Notebook 2 파일에 필드는 슬래쉬 구분자로 구분되고,
해당 월 정보를 숫자 대신에 영문월이 사용되어 있다.
좀더 보면, 일부 월명칭이 문자 세자리인 반면, 다른 월명칭은 네자리고,
날짜는 한자리 혹은 두자리로 기록되어 있다.

### 단순한 문자열 연산을 사용하면 재빨리 싫증나는 노가다가 된다.

Notebook 2 파일에서 데이터를 추출하는 정규표현식 사용법을 살펴보기 전에,
단순한 문자열 연산으로 동일한 작업을 수행하는 법을 살펴보자.
레코드가 `'Davison/May 22, 2010/1721.3'` 처럼 보인다면,
슬래쉬를 구분자로 사용해서 장소, 일자, 측정값 필드로 쪼갤 수 있다.
그리고 나서, 월,일,연도로 쪼개는데 공백을 사용하고 나서,
일자에 콤마가 있는 경우 콤마를 제거한다(일부 측정값의 경우 날짜 다음뒤에 콤마가 없다).

이런 방식으로 문제를 해결하는 것이 **절차적(procedural)** 방식으로 [절차적 프로그래밍(procedural programming)](https://en.wikipedia.org/wiki/Procedural_programming)에 기반하고 있다:
컴퓨터에게 정답을 얻는데 단계별로 수행해야 되는 절차를 명세해서 전달한다.
이와는 대조적으로 정규표현식은 **선언적(declarative)** 방식으로 [선언적 프로그래밍(declarative programming)](https://en.wikipedia.org/wiki/Declarative_programming):
"이것이 원하는 것이다" 선언하고, 컴퓨터가 연산하는 방식을 알아내도록 한다.

훌륭한 정의는 다른 문자를 대신해서 문자를 정의하는 것에 달려있다.
문자열을 나열해서 명시적으로 정의하는 것은 큰 도움이 되지 못한다.
따라서, 일반적인 패턴을 정의하는 뭔가가 필요하다. 이 지점이 정규표현식에 연산자가 
도움이 되는 곳이다.


### 정규표현식을 단순화하는데 연산자로 패턴을 명세한다.

연산자는 정규표현식에 있어 밥과 김치같이 가장 기본적인 구성요소다.
연산자는 단순히 보면 다른 패턴 (종종 가변길이를 갖는)문자를 명세하는 문자다.

앞서 연산자 활용을 살펴봤다. 다수 GUI 찾기 기능 혹은 명령-라인 와일드카드에서 친숙한
`*` 연산자가 매우 흔한 활용 사례다.
`\s` 같은 문자열 조합도 또한 연산자.

다음에 퀴즈가 하나 있다. `txt/files/file.txt` 텍스트 파일에서 `txt/files/(*.txt)`
패턴을 사용하려고 하면 결과는 어떨까?

1. `file.txt` 파일을 매칭한다.
2. 문자열 전체를 매칭한다.
3. 절대로 동작하지 않는다 (정규표현식이 패턴을 컴파일하지 않는다)

놀랍게도, 정답은 `3` 이다. 정규표현식이 패턴을 컴파일하지 않는데,
이유는 `.`와 `*`은 GUI 검색상자처럼 동일한 것을 의미하는 연산자는 아니고,
정규표현식을 생성할 때 갓차(gotcha)[^1]의 원천이 된다.

[^1]: [Gotcha (programming)](https://en.wikipedia.org/wiki/Gotcha_(programming)) 프로그래밍에서 갓차는 적법한 구성체로 문서에 기술된 대로 동작하지만, 실수를 유발하고 직관에 반대되는 결과를 가져온다.


### 연산자 사용하기

데이터를 파싱하는 첫번째 시도는 `*` 연산자를 사용하는 것이다. `*` 연산자는 
후위 연산자(postfix operator)로 "연산자 앞에 오는 패턴에 대한 0 혹은 그 이상 반복"을 의미한다.
예를 들어, `a*`는 `a` 문자 혹은 그 이상 `a`문자를 매칭한다.
반면에, `.*`는 (빈 문자열을 포함해서) 임의 연속된 문자를 매칭한다. 이유는 `.`이 임의 문자를 
매칭하고, `*`이 반복되기 때문이다.
`.*`로 매칭되는 문자가 모두 같을 필요는 *없다*: 매칭규칙이
"점에 대해 문자를 매칭하고 나서 0번 혹은 그 이상 패칭을 반복하는 것"이 아니라,
오히려 "0번 혹은 그 이상 어떤 문자든 매칭하라"는 의미이기 때문이다.

다음에 `.*`를 사용한 간단한 매칭 테스트가 나와 있다:

~~~ {.python}
match = re.search('(.*)/(.*)/(.*)',
                  'Davison/May 22, 2010/1721.3')
print match.group(1)
print match.group(2)
print match.group(3)
~~~

전체 패턴이 매칭되려면, 슬래쉬 `/`가 정확하게 줄맞춰 있어야 된다.
왜냐하면, '/'은 그자체로 매칭되기 때문이다.
이 제약조건으로 `.*`를 세번 사용해서 사이트명, 날짜, 측정값을 매칭할 수 있다.
물론, 결과는 다음과 같다:

~~~ {.output}
Davison
May 22, 2010
1271.3
~~~

불행하게도, 너무나도 사용자를 배려하지 않았다.
출력결과 각 그룹집단마다 꺾쇠 괄호를 쳐서 매칭된 것을 보기 쉽게하고 나서,
`'//'` 문자열에 동일한 패턴을 매칭하자.

~~~ {.python}
match = re.search('(.*)/(.*)/(.*)',
                  '//')
print '[' + match.group(1) + ']'
print '[' + match.group(2) + ']'
print '[' + match.group(3) + ']'
~~~

~~~ {.output}
[]
[]
[]
~~~

작성된 패턴이 위와 같은 적법하지 않는 레코드에 매칭시키고 싶지는 않다.
("Fail early, fail often" 원칙을 기억하라)
하지만, `.*` 패턴은 빈 문자열도 매칭할 수 있는데, 이유는
문자가 0번 출현해도 적용되기 때문이다.

`*` 대신에 `+`로 변형해서 시도해 보자.
`+`도 후위 연산자로 "하나 혹은 그이상" 의미를 담고 있다.
즉, 후위연산자 앞에 오는 패턴이 적어도 1회 매칭되어야만 된다.

~~~ {.python}
match = re.search('(.+)/(.+)/(.+)',
                  '//')
print match
~~~

~~~
None
~~~

보시다시피, `(.+)/(.+)/(.+)` 패턴은 슬래쉬만 담긴 문자열은 매칭하지 *않는다*.
왜냐하면, 슬래쉬 다음에 혹은 앞에, 사이에 문자가 없기 때문이다.
다시 거슬러 올라가서 적법한 데이터에 적용시키면,
올바르게 작업하는 것처럼 보인다:

~~~ {.python}
print re.search('(.+)/(.+)/(.+)',
                'Davison/May 22, 2010/1721.3')
print '[' + m.group(1) + ']'
print '[' + m.group(2) + ']'
print '[' + m.group(3) + ']'
~~~

~~~ {.output}
[Davison]
[May 22, 2010]
[1721.3]
~~~

문자열 다수에 많은 패턴을 패칭할 예정이라,
함수로 작성해서 패턴을 텍스트에 적용시키고, 매칭되는지 되지 않는지 
출력하고 나서, 매칭되는 것이 있다면 매칭되는 그룹집단을 출력한다.

~~~ {.python}
def show_groups(pattern, text):
    m = re.search(pattern, text)
    if m is None:
        print 'NO MATCH'
        return
    for i in range(1, 1 + len(m.groups())):
        print '%2d: %s' % (i, m.group(i))
~~~

방금 전에 사용한 레코드 두개에 대해 작성한 함수를 테스트해 본다:

~~~ {.python}
show_groups('(.+)/(.+)/(.+)',
            'Davison/May 22, 2010/1721.3')
~~~

~~~ {.output}
1: Davison
2: May 22, 2010
3: 1721.3
~~~

~~~ {.python}
show_groups('(.+)/(.+)/(.+)',
            '//')
~~~

~~~ {.output}
NO MATCH
~~~

좋아요: 정규표현식을 사용해서 장소명, 날짜 측정값을 추출했으면,
패턴을 더 추가해서 날짜에 대해 날짜를 더 쪼개는 것은 어떤가요?

~~~ {.python}
show_groups('(.+)/(.+) (.+), (.+)/(.+)',
            'Davison/May 22, 2010/1721.3')
~~~

~~~ {.output}
1: Davison
2: May
3: 22
4: 2010
5: 1721.3
~~~

하지만, 잠시만: 왜 동작하지 않을까요?

~~~ {.python}
show_groups('(.+)/(.+) (.+), (.+)/(.+)',
            'Davison/May 22 2010/1721.3')
~~~

~~~ {.output}
None
~~~

문제는 매칭하려는 문자열이 날짜 뒤에 콤마가 없기 때문이다. 
패턴에 이런 경우가 있어서, 매칭이 실패했다.

이 문제를 해결하는데 `*`를 콤마 뒤에 넣는 패턴을 작성할 수 있지만,
데이터에 연속된 콤마도 매칭하게 되서 원하는 바는 아니다.
대신에, 또다른 후위 연산자 `?` 물음표를 사용한다. `?`는 "바로 앞에 오는 것이 0회 혹은 1회"라는
의미를 갖는다. 이를 달리 말하면, 물음표 앞에 오는 패턴은 선택옵션이 된다.
테스트를 다시 돌리면, 두 경우 모두에 정답이 도출된다:


~~~ {.python}
# 데이터에 콤마가 있는 경우
show_groups('(.+)/(.+) (.+),? (.+)/(.+)',
            'Davison/May 22, 2010/1721.3')
~~~

~~~ {.output}
1: Davison
2: May
3: 22
4: 2010
5: 1721.3
~~~

~~~ {.python}
# 데이터에 콤마가 없는 경우
show_groups('(.+)/(.+) (.+),? (.+)/(.+)',
            'Davison/May 22 2010/1721.3')
~~~

~~~ {.output}
1: Davison
2: May
3: 22
4: 2010
5: 1721.3
~~~

패턴을 좀더 엄격하게 작성해 보자.
다음 레코드는 매칭하고 싶지 *않다*:

~~~ {.output}
Davison/May 22, 201/1721.3
~~~

누군가 연도를 잘못 타이핑해서, 4자리 대신에 3자리를 입력했다. (만일
이 기록이 맞다면, 물리학과 타이머신을 사용했을 수도 있다)
정확하세 숫자 4자리를 매칭하는 패턴을 강제하는데 연속해서 점을 네개 찍는다.

~~~ {.python}
(.+)/(.+) (.+),? (....)/(.+)
~~~

하지만, 상기 패턴방식은 가독성에 있어 장점이 없다.
대신에, 점 뒤에 `{}` 괄호 내부에 숫자 `4`를 넣자:

~~~ {.python}
(.+)/(.+) (.+),? (.{4})/(.+)
~~~

정규표현식에서, 괄호 사이 숫자는 "정확하게 해당 숫자만큼 패턴을 매칭"하라는 의미가 된다.
`.`은 임의 문자를 매칭하고, `.{4}`는 "임의 문자 4회 매칭"하라를 의미한다.

테스트를 더 수행해 보자. 다음에 날짜가 올바르거나 손상된 레코드가 일부 있다:

~~~ {.python}
tests = (
    'Davison/May , 2010/1721.3',
    'Davison/May 2, 2010/1721.3',
    'Davison/May 22, 2010/1721.3',
    'Davison/May 222, 2010/1721.3',
    'Davison/May 2, 201/1721.3',
    'Davison/ 22, 2010/1721.3',
    '/May 22, 2010/1721.3',
    'Davison/May 22, 2010/'
)
~~~

그리고, 올바른 모든 레코드는 매칭해야 하지만,
훼손된 모든 레코드는 매칭을 하면 안된다:

~~~ {.python}
pattern = '(.+)/(.+) (.{1,2}),? (.{4})/(.+)'
~~~

연도에 대해 숫자 4자리를 예상하고 있고, 일자에 대해 1자리 혹은 2자리만
허용하고 있는데 이유는 표현식 `{M,N}`은 M번부터 N번까지 패턴을 매칭하기 때문이다.

테스트 데이터에 상기 패턴을 매칭하면, 레코드 3개가 매칭된다:

~~~ {.python}
show_matches(pattern, tests)
~~~

~~~ {.output}
** Davison/May , 2010/1721.3
** Davison/May 2, 2010/1721.3
** Davison/May 22, 2010/1721.3
   Davison/May 222, 2010/1721.3
   Davison/May 2, 201/1721.3
   Davison/ 22, 2010/1721.3
   /May 22, 2010/1721.3
   Davison/May 22, 2010/
~~~

두번째와 세번째 매칭은 이해가 간다:`May 2` 와 `May 22`은 둘다 적법하다.
하지만, 날짜가 없는 `May` 모두를 왜 상기 패턴이 매칭할까?
테스트 사례를 좀더 자세히 살펴보자:

~~~ {.python}
show_groups('(.+)/(.+) (.{1,2}),? (.{4})/(.+)',
            'Davison/May , 2010/1721.3')
~~~

~~~ {.output}
1: Davison
2: May
3: ,
4: 2010
5: 1721.3
~~~


